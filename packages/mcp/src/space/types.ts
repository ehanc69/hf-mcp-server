import { z } from 'zod';

/**
 * Operations supported by the space tool (standard mode)
 */
export const OPERATION_NAMES = ['find', 'view_parameters', 'invoke'] as const;
export type OperationName = (typeof OPERATION_NAMES)[number];

/**
 * Operations supported by the space tool (discover mode)
 */
export const DISCOVER_OPERATION_NAMES = ['discover', 'view_parameters', 'invoke'] as const;
export type DiscoverOperationName = (typeof DISCOVER_OPERATION_NAMES)[number];

/**
 * Zod schema for operation arguments (standard mode with find)
 */
export const spaceArgsSchema = z.object({
	operation: z.enum(OPERATION_NAMES).optional().describe('Operation to execute.'),
	space_name: z
		.string()
		.optional()
		.describe(
			'The Hugging Face space ID (format: "username/space-name"). Required for view_parameters and invoke operations.'
		),
	parameters: z.string().optional().describe('For invoke operation: JSON object string of parameters'),
	search_query: z
		.string()
		.optional()
		.describe(
			'For find operation: Search query or task category (e.g. "Image Generation", "OCR", "FLUX image generation") to find MCP-enabled Spaces. Call with blank query to see task hints.'
		),
	limit: z.number().optional().describe('For find operation: Maximum number of results to return (default: 10)'),
});

export type SpaceArgs = z.infer<typeof spaceArgsSchema>;

/**
 * Zod schema for operation arguments (discover mode with curated list)
 */
export const discoverArgsSchema = z.object({
	operation: z.enum(DISCOVER_OPERATION_NAMES).optional().describe('Operation to execute.'),
	space_name: z
		.string()
		.optional()
		.describe(
			'The Hugging Face space ID (format: "username/space-name"). Required for view_parameters and invoke operations.'
		),
	parameters: z.string().optional().describe('For invoke operation: JSON object string of parameters'),
});

export type DiscoverArgs = z.infer<typeof discoverArgsSchema>;

/**
 * Parameter information extracted from schema
 */
export interface ParameterInfo {
	name: string;
	type: string;
	description?: string;
	required: boolean;
	default?: unknown;
	enum?: unknown[];
	isFileData?: boolean;
	complexType?: string; // Reason why the type is complex
}

/**
 * Result of schema complexity analysis
 */
export interface SchemaComplexityResult {
	isSimple: boolean;
	reason?: string; // Reason if not simple
	parameters: ParameterInfo[];
	toolName: string;
	toolDescription?: string;
}

/**
 * Result of parameter processing
 */
export interface ProcessParametersResult {
	valid: boolean;
	parameters?: Record<string, unknown>;
	error?: string;
	warnings?: string[];
}

/**
 * JSON Schema property definition
 */
export interface JsonSchemaProperty {
	type?: string;
	title?: string;
	description?: string;
	default?: unknown;
	enum?: unknown[];
	format?: string;
	properties?: Record<string, JsonSchemaProperty>;
	items?: JsonSchemaProperty;
	required?: string[];
	[key: string]: unknown;
}

/**
 * JSON Schema definition
 */
export interface JsonSchema {
	type?: string;
	properties?: Record<string, JsonSchemaProperty>;
	required?: string[];
	description?: string;
	[key: string]: unknown;
}

/**
 * File input help message constant
 */
export const FILE_INPUT_HELP_MESSAGE =
	'Provide a publicly accessible URL (http:// or https://) for the Gradio file input. ' +
	"Content previously generated by 'invoke' is usable, as well as Hub Repository URLs. ";

/**
 * Check if a property is a FileData type
 */
export function isFileDataProperty(prop: JsonSchemaProperty): boolean {
	return (
		prop.title === 'ImageData' ||
		prop.title === 'FileData' ||
		(prop.format?.includes('http') && prop.format?.includes('file')) ||
		false
	);
}

/**
 * Check if a schema contains file data
 */
export function hasFileData(schema: JsonSchema): boolean {
	if (!schema.properties) return false;

	return Object.values(schema.properties).some((prop) => isFileDataProperty(prop));
}

/**
 * Extended result type for invoke operation that includes raw MCP result
 * This allows the space tool to return structured content blocks instead of formatted text
 */
export interface InvokeResult {
	result: {
		content: unknown[];
		isError?: boolean;
		[key: string]: unknown;
	};
	warnings: string[];
	totalResults: number;
	resultsShared: number;
	isError?: boolean;
}
